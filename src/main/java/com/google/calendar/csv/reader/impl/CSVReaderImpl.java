package com.google.calendar.csv.reader.impl;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.apache.log4j.Logger;

import com.google.calendar.constant.CalendarConstant;
import com.google.calendar.csv.reader.CSVReader;

/**
 * This class will used to read the csv file and convert the csv file data into
 * map object
 *
 * @author DAMCO
 */
public class CSVReaderImpl implements CSVReader {

    public final Logger logger = Logger.getLogger(CSVReaderImpl.class);

    /*
     * (non-Javadoc)
     *
     * @see com.google.calendar.csv.reader.CSVReader#readCSV(javax.servlet.http.
     * HttpServletRequest, javax.servlet.http.HttpServletResponse)
     */
    @SuppressWarnings("rawtypes")
    @Override
    public Map<String, String> readCSV(final HttpServletRequest request, final HttpServletResponse response) {

	final DiskFileItemFactory factory = new DiskFileItemFactory();
	factory.setSizeThreshold(CalendarConstant.MAXMEMSIZE);

	// Location to save data that is larger than maxMemSize.
	factory.setRepository(new File(CalendarConstant.TEMP_STORAGE_LOCATION));
	final ServletFileUpload upload = new ServletFileUpload(factory);
	upload.setSizeMax(CalendarConstant.MAXFILESIZE);

	// Create input from CSV
	BufferedReader bufferReader = null;

	try {
	    final List fileItems = upload.parseRequest(request);
	    final Iterator iterator = fileItems.iterator();
	    InputStream inputStream = null;
	    while (iterator.hasNext()) {
		final FileItem fileItem = (FileItem) iterator.next();
		if (!fileItem.isFormField()) {

		    // opens the Input stream for the CSV input file.
		    inputStream = fileItem.getInputStream();

		} else {
		    throw new FileNotFoundException();
		}
	    }

	    // stores the date of CSV file in a Buffer
	    bufferReader = new BufferedReader(new InputStreamReader(inputStream, "UTF-8"));

	    logger.info("Reading CSV file.............");
	    return generateMapForInput(request, response, bufferReader);

	} catch (final Exception e) {
	    logger.error(CalendarConstant.LOGGER_DEFAULT_MESSAGE, e);
	    try {
		request.setAttribute(CalendarConstant.ERROR_MESSAGE, CalendarConstant.ERROR_IN_FILE_SELECTION);
		request.getRequestDispatcher(CalendarConstant.HOME_PAGE).forward(request, response);
	    } catch (ServletException | IOException e1) {
		logger.error(CalendarConstant.LOGGER_DEFAULT_MESSAGE, e1);
		request.setAttribute(CalendarConstant.ERROR_MESSAGE, CalendarConstant.ERROR_IN_LOADING);
	    }
	} finally {
	    if (bufferReader != null) {
		try {
		    bufferReader.close();
		} catch (final IOException e) {
		    logger.error(CalendarConstant.LOGGER_DEFAULT_MESSAGE, e);
		}
	    }
	}

	return new HashMap<>();
    }

    /**
     * This method parses the string provided in the input CSV file. While
     * parsing, a MAP is generated for the KEY-VALUE of input file.
     *
     * @param request
     *            HttpServletRequest object with INPUT CSV file.
     * @param response
     *            HttpServletResponse object that will contain Exception message
     *            if occurred
     * @param bufferReader
     *            A buffer storing data present in CSV file
     * @return Map of input parameter generated by reading CSV file.
     * @throws IOException
     * @throws ServletException
     */
    private Map<String, String> generateMapForInput(final HttpServletRequest request,
	    final HttpServletResponse response, final BufferedReader bufferReader)
	    throws IOException, ServletException {
	final Map<String, String> inputMap = new LinkedHashMap<>();
	String line;
	String lastKey = "";
	if ((line = bufferReader.readLine()) != null) {

	    // Splits the input provided in CSV file with SPACE.
	    final String[] argument = line.split(" ");
	    for (final String string : argument) {
		// String is further split with ":" with limit 2.
		final String[] keyValue = string.split(CalendarConstant.COL_SPLITTER, 2);
		if ((keyValue != null) && (keyValue.length == 2)) {
		    // If after split, we have 2 strings then put it in MAP with
		    // 1st string as KEY and 2nd one as VALUE.
		    inputMap.put(keyValue[0].trim(), keyValue[1].trim());
		    lastKey = keyValue[0].trim();
		}
		if ((keyValue != null) && (keyValue.length == 1)) {
		    // if after split, we have only one string then Append the
		    // string with the EXISTING VALUE of the KEY in
		    // the MAP with " " between them
		    inputMap.replace(lastKey, inputMap.get(lastKey).concat(" ").concat(keyValue[0].trim()));
		}
	    }

	} else {
	    request.setAttribute(CalendarConstant.ERROR_MESSAGE, CalendarConstant.ERROR_IN_FILE_SELECTION);
	    request.getRequestDispatcher(CalendarConstant.HOME_PAGE).forward(request, response);
	}
	return inputMap;
    }

}
